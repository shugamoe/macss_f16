kern_doppler = function(x) {
return(sqrt(x * (1 - x))*sin(2.1 * pi/(x + .05)))
}
doppler = function(x) {
if(length(x) == 1) {
return(kern_doppler(x))
} else {
rv = c()
for(num in x) {
rv = append(rv, kern_doppler(num))
}
return(rv)
}
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
obs = doppler(xs) + sig * rnorm(obs)
llr = density(obs)
return(llr, obs)
}
model()
xs
doppler((1:1000)/1000 + .1*rnorm(1000))
kern_doppler = function(x) {
return(sqrt(x * (1 - x))*sin(2.1 * pi/(x + .05)))
}
doppler = function(x) {
if(length(x) == 1) {
return(kern_doppler(x))
} else {
rv = c()
for(num in x) {
rv = append(rv, kern_doppler(num))
}
return(rv)
}
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
obs = doppler(xs) + sig * rnorm(obs)
llr = density(obs)
return(llr)
}
model()
kern_doppler = function(x) {
return(sqrt(x * (1 - x))*sin(2.1 * pi/(x + .05)))
}
doppler = function(x) {
if(length(x) == 1) {
return(kern_doppler(x))
} else {
rv = c()
for(num in x) {
rv = append(rv, kern_doppler(num))
}
return(rv)
}
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
obs = doppler(xs) + sig * rnorm(num_obs)
llr = density(obs)
return(llr)
}
model()
c = as.array(c(1,2,3))
c
typeoef(c)
typeof(c)
c = as.list(c(1,2,3))
typeof(c)
kern_doppler = function(x) {
return(sqrt(x * (1 - x))*sin(2.1 * pi/(x + .05)))
}
doppler = function(x) {
if(length(x) == 1) {
return(kern_doppler(x))
} else {
rv = c()
for(num in x) {
rv = append(rv, kern_doppler(num))
}
return(rv)
}
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
obs = doppler(xs) + sig * rnorm(num_obs)
llr = density(obs)
return(as.list(llr, obs))
}
model()
h = model()
h
names(h)
names(density)
abs(-5)
abs(5)
abs(-5)
kern_base = function(x) {
return(sqrt(x * (1 - x))*sin(2.1 * pi/(x + .05)))
}
doppler = function(x) {
if(length(x) == 1) {
return(kern_base(x))
} else {
rv = c()
for(num in x) {
rv = append(rv, kern_base(num))
}
return(rv)
}
}
tricube = function(x) {
return(70 / 81 * (1 - ind(x) ^ 3) ^ 3 * ind(x))
}
ind = function(x) {
if(abs(x) <= 1) {
return(1)
} else {
return(0)
}
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
obs = doppler(xs) + sig * rnorm(num_obs)
llr = density(obs)
return(as.list(llr, obs))
}
ind(5)
ind(.5)
tricube(5)
tricube(0)
tricube(.5)
tricube(.7)
kern_base = function(x) {
return(sqrt(x * (1 - x))*sin(2.1 * pi/(x + .05)))
}
doppler = function(x) {
if(length(x) == 1) {
return(kern_base(x))
} else {
rv = c()
for(num in x) {
rv = append(rv, kern_base(num))
}
return(rv)
}
}
tricube = function(x) {
return(70 / 81 * (1 - abs(x) ^ 3) ^ 3 * ind(x))
}
ind = function(x) {
if(abs(x) <= 1) {
return(1)
} else {
return(0)
}
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
obs = doppler(xs) + sig * rnorm(num_obs)
llr = density(obs)
return(as.list(llr, obs))
}
tricube(5)
tricube(.5)
tricube(.3)
f = as.matrix(c(1,2,3), nrow = 3, ncol = 1)
f
f[1]
f[,1]
f[,1]
f[,1]
f[,1]
f[,1]
f[,1]
f[,1]
t
t
5(t) + 3
5(t)
5*t + 3
5*t^2 + 3
t^2
t
kern_base(5)
kern_base(.5)
kern_base(c(.5, .4))
doppler = function(x) {
return(sqrt(x * (1 - x))*sin(2.1 * pi/(x + .05)))
}
# doppler = function(x) {
#   if(length(x) == 1) {
#     return(kern_base(x))
#   } else {
#     rv = c()
#     for(num in x) {
#       rv = append(rv, kern_base(num))
#     }
#   return(rv)
#   }
# }
tricube = function(x) {
return(70 / 81 * (1 - abs(x) ^ 3) ^ 3 * ind(x))
}
ind = function(x) {
if(abs(x) <= 1) {
return(1)
} else {
return(0)
}
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
obs = doppler(xs) + sig * rnorm(num_obs)
llr = density(obs)
return(as.list(llr, obs))
}
model()
c(2,2) * c(2,2)
c(2,2) * c(2,3)
sum(c(0,0,5))
t
t[1]
t[2]
t[3]
x[x[i] - x for(i in x)]
as.list(c(1,2))
x = c(1,2,3)
y = c(4,5,6)
as.list(x,y)
as.list(c(x,y))
t = c(c(1), c(5))
t
x
y
cbind(x,y)
cbind(x,y)
cbind(c(1,2,3), c(4,5,6))
cbind(x,y)
h = cbind(x,y)
h[,1]
x''
x
x[x != x[2]]
i = 2
x[x != x[i]]
test = function() {
return(PENIS)
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
ys = doppler(xs) + sig * rnorm(num_obs)
PENIS = 5
test()
}
test = function() {
return(PENIS)
}
model = function(num_obs = 1000, sig = 0.1) {
xs = (1:num_obs) / num_obs
ys = doppler(xs) + sig * rnorm(num_obs)
PENIS = 5
return(test())
}
model()
x
y
y = append(y, c(5,7,8))
5+=5
5 += 5
x
x+=5
x += 5
x
length(x
)
sample_size = c(seq(1,200))
sim = function(part_b = FALSE, ssize = sample_size, sig = 1, b = 100) {
rv = c()
for(n in sample_size){
stat_n =  c()
for(rep in (1:b)) {
mew_n = mean(rnorm(n, 1, sig))
if(part_b) {
stat_b = sqrt(n) * (mew_n - 1) # Z
} else {
stat_b = (mew_n - 1)^2 # The MSE
}
stat_n = append(stat_n, stat_b)
}
if(part_b) {
stat_rv = stat_n
} else {
stat_rv = mean(stat_n)
}
rv = append(rv, stat_rv)
}
if(part_b) {
x = seq(-4, 4, .01)
f = dnorm(x, sd = sig)
plot(density(rv), main = "Z")
lines(x,f,'l',col='red')
} else {
# Normal scale plot
plot(sample_size, rv, ylab = "")
lines(sample_size, (sig^2) / sample_size, col = "red")
title(expression(paste(frac(sigma^2, n), "vs. Empirical MSE")), line = -2)
# Log Log Plot
plot(sample_size, log = "xy", rv, ylab = "log 1", xlab = "log sample size")
lines(sample_size, (sig^2) / sample_size, col = "red")
title(expression(paste("log(", frac(sigma^2, n), ") ", "vs. log(Empirical MSE)")), line = -2)
}
}
sim()
library(gam)
gam.mcount_model = gam(mean_count ~ s(daylabel), data = new_train)
new_train$resids = resid(gam.mcount_model)
gam.resid_model = gam(resids ~ + s(atemp) + s(humidity) + s(windspeed) + weather + hour + season + workingday + holiday, data = new_train)
rmsle(new_test$count, predict(gam.resid_model, new_test) + predict(gam.mcount_model, new_test))
setwd("~/macss_f16/nonpar/hw1")
library(MASS)
library(locfit)
for(day_num in unique(new_train$daylabel)) {
mean_count = mean(new_train$count[which(new_train$daylabel == day_num)])
new_train$mean_count[which(new_train$daylabel == day_num)] = mean_count
}
plot(unique(new_train$daylabel), unique(new_train$mean_count), main = 'Means vs. Daylabel', ylab = 'Mean hourly log counts per day', xlab = 'Daylabel')
mcount.model = locfit(mean_count ~ daylabel, data = new_train, deg = 1)
plot(new_train$daylabel, fitted(mcount.model))
new_train$resids = resid(mcount.model)
resid_model = lm(resids ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# Have to add the counts from the new_test set back back so that the predict() function actually predicts counts and not residuals.
# [Q] What do you mean by combine? My RMSLE is not that good now.
rmsle(new_test$count, predict(resid_model, new_test) + predict(mcount.model, new_test))
rmsle = function(trues, estimates) {
diff = trues - estimates
return(sqrt(mean(diff ^ 2)))
}
train <- read.csv("train.csv", colClasses=c('year'="factor", "month"="factor", "hour"="factor", "season"="factor",
"holiday"="factor", "workingday"="factor", "weather"="factor"))
test <- read.csv("test.csv", colClasses=c('year'="factor", "month"="factor", "hour"="factor", "season"="factor",
"holiday"="factor", "workingday"="factor", "weather"="factor"))
train$count = log(train$count + 1)
# Split the training data into new training and new test sets
new_train = train[which(train$day <= 15),]
new_test = train[which(16 <= train$day & train$day <= 19),]
# Change day to factor
new_train$day <- as.factor(new_train$day)
new_test$day <- as.factor(new_test$day)
test$day <- as.factor(test$day)
lm0 = lm(count ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# linear_model <- lm(count ~ temp + season + weather + hour + humidity, data=new_train)
# rmsle(new_test$count, predict(linear_model, new_test))
library(MASS)
library(locfit)
for(day_num in unique(new_train$daylabel)) {
mean_count = mean(new_train$count[which(new_train$daylabel == day_num)])
new_train$mean_count[which(new_train$daylabel == day_num)] = mean_count
}
plot(unique(new_train$daylabel), unique(new_train$mean_count), main = 'Means vs. Daylabel', ylab = 'Mean hourly log counts per day', xlab = 'Daylabel')
mcount.model = locfit(mean_count ~ daylabel, data = new_train, deg = 1)
plot(new_train$daylabel, fitted(mcount.model))
new_train$resids = resid(mcount.model)
resid_model = lm(resids ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# Have to add the counts from the new_test set back back so that the predict() function actually predicts counts and not residuals.
# [Q] What do you mean by combine? My RMSLE is not that good now.
rmsle(new_test$count, predict(resid_model, new_test) + predict(mcount.model, new_test))
library(MASS)
library(locfit)
for(day_num in unique(new_train$daylabel)) {
mean_count = mean(new_train$count[which(new_train$daylabel == day_num)])
new_train$mean_count[which(new_train$daylabel == day_num)] = mean_count
}
plot(unique(new_train$daylabel), unique(new_train$mean_count), main = 'Means vs. Daylabel', ylab = 'Mean hourly log counts per day', xlab = 'Daylabel')
mcount.model = locfit(mean_count ~ daylabel, data = new_train, deg = 1)
plot(new_train$daylabel, fitted(mcount.model))
new_train$resids = resid(mcount.model)
resid_model = lm(resids ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# Have to add the counts from the new_test set back back so that the predict() function actually predicts counts and not residuals.
# [Q] What do you mean by combine? My RMSLE is not that good now.
rmsle(new_test$count, predict(resid_model, new_test) + predict(mcount.model, new_test))
rmsle(new_test$count, predict(lm0, new_test))
library(gam)
gam.model = gam(count ~ s(daylabel) + s(atemp) + s(humidity) + s(windspeed) + weather + hour + season + workingday + holiday + s(temp), data = new_train)
rmsle(new_test$count, predict(gam.model, new_test))
library(gam)
gam.mcount_model = gam(mean_count ~ s(daylabel), data = new_train)
new_train$resids = resid(gam.mcount_model)
gam.resid_model = gam(resids ~ + s(atemp) + s(humidity) + s(windspeed) + weather + hour + season + workingday + holiday, data = new_train)
rmsle(new_test$count, predict(gam.resid_model, new_test) + predict(gam.mcount_model, new_test))
library(MASS)
library(locfit)
for(day_num in unique(new_train$daylabel)) {
mean_count = mean(new_train$count[which(new_train$daylabel == day_num)])
new_train$mean_count[which(new_train$daylabel == day_num)] = mean_count
}
plot(unique(new_train$daylabel), unique(new_train$mean_count), main = 'Means vs. Daylabel', ylab = 'Mean hourly log counts per day', xlab = 'Daylabel')
mcount.model = locfit(mean_count ~ daylabel, data = new_train, deg = 1)
new_train$resids = resid(mcount.model)
resid_model = lm(resids ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# Have to add the counts from the new_test set back back so that the predict() function actually predicts counts and not residuals.
# [Q] What do you mean by combine? My RMSLE is not that good now.
rmsle(new_test$count, predict(resid_model, new_test) + predict(mcount.model, new_test))
rmsle = function(trues, estimates) {
diff = trues - estimates
return(sqrt(mean(diff ^ 2)))
}
train = read.csv("train.csv", colClasses=c('year'="factor", "month"="factor", "hour"="factor", "season"="factor",
"holiday"="factor", "workingday"="factor", "weather"="factor"))
test = read.csv("test.csv", colClasses=c('year'="factor", "month"="factor", "hour"="factor", "season"="factor",
"holiday"="factor", "workingday"="factor", "weather"="factor"))
train$count = log(train$count + 1)
# Split the training data into new training and new test sets
new_train = train[which(train$day <= 15),]
new_test = train[which(16 <= train$day & train$day <= 19),]
# Change day to factor
new_train$day = as.factor(new_train$day)
new_test$day = as.factor(new_test$day)
test$day = as.factor(test$day)
lm0 = lm(count ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# linear_model <- lm(count ~ temp + season + weather + hour + humidity, data=new_train)
# rmsle(new_test$count, predict(linear_model, new_test))
library(gam)
gam.model = gam(count ~ s(daylabel) + s(atemp) + s(humidity) + s(windspeed) + weather + hour + season + workingday + holiday + s(temp), data = new_train)
rmsle(new_test$count, predict(gam.model, new_test))
rmsle = function(trues, estimates) {
diff = trues - estimates
return(sqrt(mean(diff ^ 2)))
}
train = read.csv("train.csv", colClasses=c('year'="factor", "month"="factor", "hour"="factor", "season"="factor",
"holiday"="factor", "workingday"="factor", "weather"="factor"))
test = read.csv("test.csv", colClasses=c('year'="factor", "month"="factor", "hour"="factor", "season"="factor",
"holiday"="factor", "workingday"="factor", "weather"="factor"))
train$count = log(train$count + 1)
# Split the training data into new training and new test sets
new_train = train[which(train$day <= 15),]
new_test = train[which(16 <= train$day & train$day <= 19),]
# Change day to factor
new_train$day = as.factor(new_train$day)
new_test$day = as.factor(new_test$day)
test$day = as.factor(test$day)
lm0 = lm(count ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# linear_model <- lm(count ~ temp + season + weather + hour + humidity, data=new_train)
# rmsle(new_test$count, predict(linear_model, new_test))
rmsle(new_test$count, predict(lm0, new_test))
library(MASS)
library(locfit)
for(day_num in unique(new_train$daylabel)) {
mean_count = mean(new_train$count[which(new_train$daylabel == day_num)])
new_train$mean_count[which(new_train$daylabel == day_num)] = mean_count
}
plot(unique(new_train$daylabel), unique(new_train$mean_count), main = 'Means vs. Daylabel', ylab = 'Mean hourly log counts per day', xlab = 'Daylabel')
mcount.model = locfit(mean_count ~ daylabel, data = new_train, deg = 1)
resids = resid(mcount.model)
resid_model = lm(resids ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# Have to add the counts from the new_test set back back so that the predict() function actually predicts counts and not residuals.
# [Q] What do you mean by combine? My RMSLE is not that good now.
rmsle(new_test$count, predict(resid_model, new_test) + predict(mcount.model, new_test))
resids
dim(new_train)
library(MASS)
library(locfit)
for(day_num in unique(new_train$daylabel)) {
mean_count = mean(new_train$count[which(new_train$daylabel == day_num)])
new_train$mean_count[which(new_train$daylabel == day_num)] = mean_count
}
plot(unique(new_train$daylabel), unique(new_train$mean_count), main = 'Means vs. Daylabel', ylab = 'Mean hourly log counts per day', xlab = 'Daylabel')
mcount.model = locfit(mean_count ~ daylabel, data = new_train, deg = 1)
new_train$resids = resid(mcount.model)
resid_model = lm(resids ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# Have to add the counts from the new_test set back back so that the predict() function actually predicts counts and not residuals.
# [Q] What do you mean by combine? My RMSLE is not that good now.
rmsle(new_test$count, predict(resid_model, new_test) + predict(mcount.model, new_test))
new_train$resids
head(new_train)
library(gam)
gam.mcount_model = gam(mean_count ~ s(daylabel), data = new_train)
new_train$resids = resid(gam.mcount_model)
gam.resid_model = gam(resids ~ + s(atemp) + s(humidity) + s(windspeed) + weather + hour + season + workingday + holiday, data = new_train)
rmsle(new_test$count, predict(gam.resid_model, new_test) + predict(gam.mcount_model, new_test))
library(MASS)
library(locfit)
for(day_num in unique(new_train$daylabel)) {
mean_count = mean(new_train$count[which(new_train$daylabel == day_num)])
new_train$mean_count[which(new_train$daylabel == day_num)] = mean_count
}
plot(unique(new_train$daylabel), unique(new_train$mean_count), main = 'Means vs. Daylabel', ylab = 'Mean hourly log counts per day', xlab = 'Daylabel')
mcount.model = locfit(mean_count ~ daylabel, data = new_train, deg = 1)
new_train$resids = resid(mcount.model)
resid_model = lm(resids ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# Have to add the counts from the new_test set back back so that the predict() function actually predicts counts and not residuals.
# [Q] What do you mean by combine? My RMSLE is not that good now.
rmsle(new_test$count, predict(resid_model, new_test) + predict(mcount.model, new_test))
head(new_train)
library(MASS)
library(locfit)
for(day_num in unique(new_train$daylabel)) {
mean_count = mean(new_train$count[which(new_train$daylabel == day_num)])
new_train$mean_count[which(new_train$daylabel == day_num)] = mean_count
}
plot(unique(new_train$daylabel), unique(new_train$mean_count), main = 'Means vs. Daylabel', ylab = 'Mean hourly log counts per day', xlab = 'Daylabel')
mcount.model = locfit(mean_count ~ daylabel, data = new_train)
new_train$resids = resid(mcount.model)
resid_model = lm(resids ~ workingday + holiday + season + daylabel + hour + weather + atemp + humidity*windspeed, data = new_train)
# Have to add the counts from the new_test set back back so that the predict() function actually predicts counts and not residuals.
# [Q] What do you mean by combine? My RMSLE is not that good now.
rmsle(new_test$count, predict(resid_model, new_test) + predict(mcount.model, new_test))
head(new_train)
library(gam)
help(s)
