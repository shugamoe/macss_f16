---
title: "STAT 374 | HW1 "
author: "Julian McClellan"
date: "April 23, 2016"
output:
  pdf_document:
    toc: true
    highlight: zenburn
    fig_height: 3.5
---
## 1. Computing and plotting with R(15 points)

### (a)



```{r, tidy=TRUE, tidy.opts=list(width.cutoff=60)}
sample_size = c(seq(1,200))
sim = function(part_b = FALSE, ssize = sample_size, sig = 1, b = 100) {
  rv = c()
  for(n in sample_size){
    stat_n =  c()
    
    for(rep in (1:b)) {
      mew_n = mean(rnorm(n, 1, sig))
      if(part_b) {
        stat_b = sqrt(n) * (mew_n - 1) # Z
      } else {
        stat_b = (mew_n - 1)^2 # The MSE
      }
      stat_n = append(stat_n, stat_b)
    }
    
    if(part_b) {
      stat_rv = stat_n
    } else {
      stat_rv = mean(stat_n)
    }
    rv = append(rv, stat_rv) 
  }
  if(part_b) {
    x = seq(-4, 4, .01)
    f = dnorm(x, sd = sig)
    plot(density(rv), main = "Z")
    lines(x,f,'l',col='red')
  } else {
    # Normal scale plot
    plot(sample_size, rv, ylab = "")
    lines(sample_size, (sig^2) / sample_size, col = "red")
    title(expression(paste(frac(sigma^2, n), "vs. Empirical MSE")), line = -2) 
    
    # Log Log Plot
    plot(sample_size, log = "xy", rv, ylab = "log 1", xlab = "log sample size")
    lines(sample_size, (sig^2) / sample_size, col = "red")
    title(expression(paste("log(", frac(sigma^2, n), ") ", "vs. log(Empirical MSE)")), line = -2)
  }
  
}
```

### (b)
```{r, tidy=TRUE, tidy.opts=list(width.cutoff=60)}
zs = sim(TRUE)
plot(sample_size, zs)
```

## 2. Leave-ne-out cross-validation (20 points)

### (a)

### (b)

```{r, tidy=TRUE, tidy.opts=list(width.cutoff=60)}

kern_base = function(x) {
  return(sqrt(x * (1 - x))*sin(2.1 * pi/(x + .05)))
}

doppler = function(x) {
  if(length(x) == 1) {
    return(kern_base(x))
  } else {
    rv = c()
    for(num in x) {
      rv = append(rv, kern_base(num))
    }
  return(rv)
  }
}

tricube = function(x) {
  return(70 / 81 * (1 - abs(x) ^ 3) ^ 3 * ind(x))
}

ind = function(x) {
  if(abs(x) <= 1) {
    return(1)
  } else {
    return(0)
  }
}

model = function(num_obs = 1000, sig = 0.1) {
  xs = (1:num_obs) / num_obs
  obs = doppler(xs) + sig * rnorm(num_obs)
  
  llr = density(obs)
  return(as.list(llr, obs))
}
```
